{{- define "unwrapFunc" -}}
    {{- if .SetterType.IsNullable -}}
        {{- if .UnwrapFunc -}}
            optionutil.SetOmitNullConvert[{{.SetterType.Elem}}, {{.ModelsType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, {{.NullConstructorFunc}}, {{.UnwrapFunc}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- else if ne .SetterType.Elem .ModelsType.Elem -}}
            optionutil.SetOmitNullConvert[{{.SetterType.Elem}}, {{.ModelsType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, {{.NullConstructorFunc}}, func(t {{.SetterType.Elem}}) {{.ModelsType.Elem}} { return {{.ModelsType.Elem}}(t) }, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- else -}}
            optionutil.SetOmitNull[{{.SetterType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, {{.NullConstructorFunc}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- end -}}
    {{- else if .SetterType.IsArray -}}
        {{- if .UnwrapFunc -}}
            optionutil.SetOmitArrayConvert[{{.SetterType.Elem}}, {{.ModelsType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, {{.UnwrapFunc}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- else if ne .SetterType.Elem .ModelsType.Elem -}}
            optionutil.SetOmitArrayConvert[{{.SetterType.Elem}}, {{.ModelsType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, func(t {{.SetterType.Elem}}) {{.ModelsType.Elem}} { return {{.ModelsType.Elem}}(t) }, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- else -}}
            optionutil.SetOmitArray[{{.SetterType.Elem}}, {{.ModelsType.Type}}](set.{{.SetterName}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- end -}}
    {{- else -}}
        {{- if .UnwrapFunc -}}
            optionutil.SetOmitConvert(set.{{.SetterName}}, {{.UnwrapFunc}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- else if ne .SetterType.Type .ModelsType.Type -}}
            {{.ModelsType.Type}}(optionutil.SetOmit(set.{{.SetterName}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt))
        {{- else -}}
            optionutil.SetOmit(set.{{.SetterName}}, {{.ColumnConstant}}, &setCols, {{.Index}}, &setColsInt)
        {{- end -}}
    {{- end -}}
{{- end -}}

{{- define "wrapField" -}}
    {{- if .RelName -}}
        {{- if .RelType.IsArray -}}
            Wrap{{.RelType.TrueElem}}s(e.R.{{.RelName}}...)
        {{- else -}}
            Wrap{{.RelType.TrueElem}}(e.R.{{.RelName}})
        {{- end -}}
    {{- else if .ModelsType.IsNullable -}}
        {{- if .WrapFunc -}}
            optionutil.ConvertPtr(e.{{.ModelsName}}.Ptr(), {{.WrapFunc}})
        {{- else if ne .GetterType.Elem .ModelsType.Elem -}}
            optionutil.ConvertPtr(e.{{.ModelsName}}.Ptr(), func(t {{.ModelsType.Elem}}) {{.GetterType.Elem}} { return {{.GetterType.Elem}}(t) })
        {{- else -}}
            e.{{.ModelsName}}.Ptr()
        {{- end -}}
    {{- else if .ModelsType.IsArray -}}
        {{- if .WrapFunc -}}
            optionutil.ConvertSlice(e.{{.ModelsName}}, {{.WrapFunc}})
        {{- else if ne .GetterType.Elem .ModelsType.Elem -}}
            optionutil.ConvertSlice(e.{{.ModelsName}}, func(t {{.ModelsType.Elem}}) {{.GetterType.Elem}} { return {{.GetterType.Elem}}(t) })
        {{- else -}}
            {{.GetterType.Type}}(e.{{.ModelsName}})
        {{- end -}}
    {{- else -}}
        {{- if .WrapFunc -}}
            {{.WrapFunc}}(e.{{.ModelsName}})
        {{- else if ne .GetterType.Type .ModelsType.Type -}}
            {{.GetterType.Type}}(e.{{.ModelsName}})
        {{- else -}}
            e.{{.ModelsName}}
        {{- end -}}
    {{- end -}}
{{- end -}}


package {{.ModelsPackage}}

import (
    "github.com/mavolin/repogen/module/boil/optionutil"
    "github.com/volatiletech/null/v8"
    "github.com/volatiletech/sqlboiler/v4/boil"
    "github.com/volatiletech/sqlboiler/v4/types"
)

// Code generated by github.com/mavolin/repogen. DO NOT EDIT.

{{ range .Entities }}
{{- if not .NoUnwrap }}
func Unwrap{{.SetterName}}(setter {{.QualSetterName}}) ({{.ModelsName}}, boil.Columns) {
    e, cols, _ := unwrap{{.SetterName}}(setter)
    return e, cols
}

type {{.ModelsName}}Batch struct {
    Models []{{.ModelsName}}
    Columns boil.Columns
}

func Unwrap{{.SetterName}}s(setters ...{{.QualSetterName}}) []{{.ModelsName}}Batch {
    batches := make(map[uint64]{{.ModelsName}}Batch, len(setters))

    for _, setter := range setters {
        e, cols, id := unwrap{{.SetterName}}(setter)
        batch, ok := batches[id]
        if !ok {
            batch.Columns = cols
        }
        batch.Models = append(batch.Models, e)
        batches[id] = batch
    }

    batchSlice := make([]{{.ModelsName}}Batch, 0, len(batches))
    for _, batch := range batches {
        batchSlice = append(batchSlice, batch)
    }

    return batchSlice
}

func unwrap{{.SetterName}}(set {{.QualSetterName}}) ({{.ModelsName}}, boil.Columns, uint64) {
    setCols := make([]string, 0, {{len .Fields}})
    var setColsInt uint64

    e := {{.ModelsName}}{
{{- range .Fields }}
    {{- if not .NoUnwrap }}
        {{.ModelsName}}: {{ template "unwrapFunc" . }},
    {{- end }}
{{- end }}
    }

    return e, boil.Greylist(setCols...), setColsInt
}

{{ end -}}
{{ if not .NoWrap }}
func Wrap{{.ModelsName}}(e *{{.ModelsName}}) *{{.QualGetterName}} {
    if e == nil {
        return nil
    }

    {{ $hasRels := false -}}
    w :={{.QualGetterName}}{
{{- range .Fields }}
    {{- if .RelName -}}{{ $hasRels = true }}{{- end -}}
    {{- if and (not .NoWrap) (not .RelName) }}
        {{.GetterName}}: {{ template "wrapField" . }},
    {{- end }}
{{- end }}
    }

{{- if $hasRels}}

    if e.R != nil {
    {{- range .Fields }}
        {{- if .RelName }}
        w.{{.GetterName}} = {{ template "wrapField" . }}
        {{- end }}
    {{- end }}
    }
{{- end }}

    return &w
}

func Wrap{{.ModelsName}}s(es ...*{{.ModelsName}}) []*{{.QualGetterName}} {
    if es == nil {
        return nil
    } else if len(es) == 0 {
        return []*{{.QualGetterName}}{}
    }

    wraps := make([]*{{.QualGetterName}}, len(es))
    for i, e := range es {
        wraps[i] = Wrap{{.ModelsName}}(e)
    }
    return wraps
}

{{ end }}
{{- end }}
